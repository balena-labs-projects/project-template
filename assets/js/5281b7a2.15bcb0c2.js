"use strict";(self.webpackChunkBalena_Labs=self.webpackChunkBalena_Labs||[]).push([[927],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=u(n),h=i,m=c["".concat(l,".").concat(h)]||c[h]||p[h]||o;return n?a.createElement(m,r(r({ref:t},d),{},{components:n})):a.createElement(m,r({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var u=2;u<o;u++)r[u]=n[u];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},1527:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>u});var a=n(7462),i=(n(7294),n(3905));const o={sidebar_position:5},r="Architecture",s={unversionedId:"architecture",id:"architecture",title:"Architecture",description:"Community contributions have been a staple of this open source project since its inception. However, as balenaSound grew in features it also grew in terms of complexity. It's currently a multi-container application with four core services and as many plugin services. This documentation section aims to provide an overview of balenaSound's architecture, with the intention of lowering the barrier to entry for folks out there wanting to contribute. If you are interested in contributing and after reading this guide you still have questions please reach out and we'll gladly help.",source:"@site/docs/architecture.md",sourceDirName:".",slug:"/architecture",permalink:"/project-template-test/architecture",draft:!1,editUrl:"https://github.com/balena-labs-projects/project-template-test/edit/main/docs/architecture.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Audio interfaces",permalink:"/project-template-test/audio-interfaces"},next:{title:"Device support",permalink:"/project-template-test/device-support"}},l={},u=[{value:"Overview",id:"overview",level:2},{value:"Sound core",id:"sound-core",level:3},{value:"Multi-room",id:"multi-room",level:3},{value:"Plugins",id:"plugins",level:3},{value:"Audio routing",id:"audio-routing",level:2},{value:"Input and output layers",id:"input-and-output-layers",level:3},{value:"Standalone",id:"standalone",level:3},{value:"Multiroom",id:"multiroom",level:3},{value:"Plugins",id:"plugins-1",level:2}],d={toc:u};function p(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"architecture"},"Architecture"),(0,i.kt)("p",null,"Community contributions have been a staple of this open source project since its inception. However, as balenaSound grew in features it also grew in terms of complexity. It's currently a multi-container application with four core services and as many plugin services. This documentation section aims to provide an overview of balenaSound's architecture, with the intention of lowering the barrier to entry for folks out there wanting to contribute. If you are interested in contributing and after reading this guide you still have questions please ",(0,i.kt)("a",{parentName:"p",href:"/project-template-test/support#contact-us"},"reach out")," and we'll gladly help."),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/balena-labs-projects/balena-sound/master/docs/images/arch-overview.png",alt:null})),(0,i.kt)("p",null,"balenaSound services can be divided in three groups:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Sound core: ",(0,i.kt)("inlineCode",{parentName:"li"},"sound-supervisor")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"audio"),"."),(0,i.kt)("li",{parentName:"ul"},"Multiroom: ",(0,i.kt)("inlineCode",{parentName:"li"},"multiroom-server")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"multiroom-client")),(0,i.kt)("li",{parentName:"ul"},"Plugins: ",(0,i.kt)("inlineCode",{parentName:"li"},"spotify"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"airplay"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"bluetooth"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"upnp"))),(0,i.kt)("h3",{id:"sound-core"},"Sound core"),(0,i.kt)("p",null,"This is the heart of balenaSound as it contains the most important services: ",(0,i.kt)("inlineCode",{parentName:"p"},"sound-supervisor")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"audio"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"audio"),"\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"audio")," block is a balena block that provides an easy way to work with audio applications in containerized environments such as balenaOS. You can read more about it ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/balenablocks/audio"},"here"),". In a nutshell, the ",(0,i.kt)("inlineCode",{parentName:"p"},"audio"),' block is the main "audio router". It connects to all audio sources and sinks and handles audio routing, which will change depending on the mode of operation (multi-room vs standalone), the output interface selected (onboard audio, HDMI, DAC, USB soundcard), etc. The ',(0,i.kt)("inlineCode",{parentName:"p"},"audio")," block allows you to build complex audio applications such as balenaSound without having to deep dive into ALSA or PulseAudio configuration. One of the key features for balenaSound is that it allows us to define input and output audio layers and then do all the complex audio routing without knowing/caring about where the audio is being generated or where it should go to. The ",(0,i.kt)("inlineCode",{parentName:"p"},"audio routing")," section belows covers this process in detail."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"sound-supervisor"),"\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"sound-supervisor"),", as its name suggests, is the service that orchestrates all the others. It's not really involved in the audio routing but it does a few key things that enable the other services to be simpler. Here are some of the most important features of the ",(0,i.kt)("inlineCode",{parentName:"p"},"sound-supervisor"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Multi-room events"),": through the use of the ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/dashersw/cote"},"cotejs")," library and interfacing with the ",(0,i.kt)("inlineCode",{parentName:"li"},"audio")," block, the ",(0,i.kt)("inlineCode",{parentName:"li"},"sound-supervisor")," ensures that all devices on the same local network agree on which is the ",(0,i.kt)("inlineCode",{parentName:"li"},"master")," device. To achieve this, ",(0,i.kt)("inlineCode",{parentName:"li"},"sound-supervisor")," services on different devices exchange event messages constantly."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"API"),": creates a REST API on port 80. The API allows other services to access the current balenaSound configuration, which allows us to update the configuration dynamically and have services react accordingly. As a general rule of thumb, if we are interested in a service's configuration being able to be dynamically updated, the service should rely on configuration reported by ",(0,i.kt)("inlineCode",{parentName:"li"},"sound-supervisor")," and not on environment variables. At this moment, all of the services support this behaviour but their configuration is mostly static: you set it at startup via environment variables and that's it. However, there are ",(0,i.kt)("em",{parentName:"li"},"experimental")," endpoints in the API to update configuration values and all of the services support it already. There's even a ",(0,i.kt)("em",{parentName:"li"},"secret")," UI that allows for some configuration changes at runtime, it's located at ",(0,i.kt)("inlineCode",{parentName:"li"},"http://<DEVICE_IP>"),".")),(0,i.kt)("h3",{id:"multi-room"},"Multi-room"),(0,i.kt)("p",null,"Multi-room services provide multiroom capabilities to balenaSound."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"multiroom-server"),"\nThis service runs a ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/badaix/snapcast"},"Snapcast")," server which is responsible for broadcasting (and syncing) audio from the ",(0,i.kt)("inlineCode",{parentName:"p"},"audio")," service into Snapcast clients. Clients can be running on the same device or on separate devices."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"multiroom-client"),"\nRuns the client version of Snapcast. It needs to connect to a Snapcast server (can be a separate device) to receive audio packets. It will then forward the audio back into the ",(0,i.kt)("inlineCode",{parentName:"p"},"audio")," service."),(0,i.kt)("h3",{id:"plugins"},"Plugins"),(0,i.kt)("p",null,"Plugins are the audio sources that generate the audio to be streamed/played (e.g. Spotify). Refer to the plugins section below for pointers on how to add new plugins."),(0,i.kt)("h2",{id:"audio-routing"},"Audio routing"),(0,i.kt)("p",null,"Audio routing is the most cruicial part of balenaSound, and it also changes significantly depending on what the current configuration is with the biggest change being the mode of operation (multi-room vs standalone). There are two services controlling the audio routing:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the ",(0,i.kt)("inlineCode",{parentName:"li"},"audio")," block is the key one as it's the one actually routing audio, so we'll zoom into it in sections below."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sound-supervisor")," on the other hand, is responsible for changing the routing according to what the current mode is. It will modify how sinks are internally connected depending on the mode of operation.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note"),": audio routing relies mainly on routing PulseAudio sinks. ",(0,i.kt)("a",{parentName:"p",href:"https://gavv.github.io/articles/pulseaudio-under-the-hood/"},"Here")," is an awesome resource on PulseAudio in case you are not familiar with it."),(0,i.kt)("h3",{id:"input-and-output-layers"},"Input and output layers"),(0,i.kt)("p",null,"One of the advantages of using the ",(0,i.kt)("inlineCode",{parentName:"p"},"audio")," block is that, since it's based on PulseAudio, we can use all the audio processing tools and tricks that are widely available, in this particular case ",(0,i.kt)("inlineCode",{parentName:"p"},"virtual sinks"),". PulseAudio clients can send audio to sinks; usually audio soundcards have a sink that represents them, so sending audio to the audio jack sink will result in that audio coming out of the audio jack. Virtual sinks are virtual nodes that can be used to route audio in and out of them."),(0,i.kt)("p",null,"For balenaSound we use two virtual sinks in order to simplify how audio is being routed:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"balena-sound.input"),(0,i.kt)("li",{parentName:"ul"},"balena-sound.output")),(0,i.kt)("p",null,"Creation and configuration scripts for these virtual sinks are located at ",(0,i.kt)("inlineCode",{parentName:"p"},"core/audio/balena-sound.pa")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"core/audio/start.sh"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"balena-sound.input"),"\n",(0,i.kt)("inlineCode",{parentName:"p"},"balena-sound.input")," acts as an input audio multiplexer/mixer. It's the default sink on balenaSound, so all plugins that send audio to the ",(0,i.kt)("inlineCode",{parentName:"p"},"audio")," block will send it to this sink by default. This allows us to route audio internally without worrying where it came from: any audio generated by a plugin will pass through the ",(0,i.kt)("inlineCode",{parentName:"p"},"balena-sound.input")," sink, so by controlling where it sends it's audio we are effectively controlling all plugins at the same time."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"balena-sound.output"),"\n",(0,i.kt)("inlineCode",{parentName:"p"},"balena-sound.output")," on the other hand is the output audio multiplexer/mixer. This one is pretty useful in scenarios where there are multiple soundcards available (onboard, DAC, USB, etc). ",(0,i.kt)("inlineCode",{parentName:"p"},"balena-sound.output")," is always wired to whatever the desired soundcard sink is. So even if we dynamically change the output selection, sending audio to ",(0,i.kt)("inlineCode",{parentName:"p"},"balena-sound.output")," will always result in audio going to the current selection. Again, this is useful to route audio internally without worrying about user selection at runtime."),(0,i.kt)("h3",{id:"standalone"},"Standalone"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/balena-labs-projects/balena-sound/master/docs/images/arch-standalone.png",alt:null})),(0,i.kt)("p",null,"Standalone mode is easy to understand. You just pipe ",(0,i.kt)("inlineCode",{parentName:"p"}," balena-sound.input")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"balena-sound.output")," and that's it. Audio coming in from any plugin will find it's way to the selected output. If this was the only mode, we could simplify the setup and use a single sink. Having the two layers however is important for the next mode which is more complicated."),(0,i.kt)("h3",{id:"multiroom"},"Multiroom"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/balena-labs-projects/balena-sound/master/docs/images/arch-multiroom.png",alt:null})),(0,i.kt)("p",null,"Multiroom feature relies on ",(0,i.kt)("inlineCode",{parentName:"p"},"snapcast")," to broadcast the audio to multiple devices. Snapcast has two binaries working alonside, server and client."),(0,i.kt)("p",null,"Snapcast server can receive audio from an ALSA stream, so we create an additional sink (",(0,i.kt)("inlineCode",{parentName:"p"},"snapcast")," sink) that routes audio from ",(0,i.kt)("inlineCode",{parentName:"p"},"balena-sound.input"),' and configure snapcast to grab the audio from the sink monitor. The server will then use TCP packets to broadcast audio to all clients that are connected to it, wether they run in the same device or others. Note that the audio is "exiting" the ',(0,i.kt)("inlineCode",{parentName:"p"},"audio")," block and no longer under PulseAudio's control."),(0,i.kt)("p",null,"Snapcast client receives the audio from the server and sends it back into the ",(0,i.kt)("inlineCode",{parentName:"p"},"audio")," block, in particular to ",(0,i.kt)("inlineCode",{parentName:"p"},"balena-sound.output")," sink which will in turn send the audio to whatever output was selected by the user."),(0,i.kt)("p",null,"This setup allows us to decouple the multiroom feature from the ",(0,i.kt)("inlineCode",{parentName:"p"},"audio")," block while retaining it's advantages."),(0,i.kt)("h2",{id:"plugins-1"},"Plugins"),(0,i.kt)("p",null,"As described above, plugins are the services generating the audio to be streamed/played. Plugins are responsible for sending the audio into the ",(0,i.kt)("inlineCode",{parentName:"p"},"audio")," block, particularily into ",(0,i.kt)("inlineCode",{parentName:"p"},"balena-sound.input")," sink. There are two alternatives for how this can be acomplished. A detailed explanation can be found ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/balenablocks/audio#usage"},"here"),", in our case:"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"PulseAudio backend")),(0,i.kt)("p",null,"Most audio applications support using PulseAudio as an audio backend. This means the application was coded to allow sending audio directly to PulseAudio (and hence the ",(0,i.kt)("inlineCode",{parentName:"p"},"audio")," block). This is usually configurable via a CLI option flag or configuration files. You should check your application's documentation and figure out if this is the case."),(0,i.kt)("p",null,"If the application supports PulseAudio backend, the only configuration you need is to specify where the PulseAudio server can be located. This can be done by setting the ",(0,i.kt)("inlineCode",{parentName:"p"},"PULSE_SERVER")," environment variable, we recommend doing it in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Dockerfile"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ENV PULSE_SERVER=tcp:localhost:4317\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"ALSA bridge")),(0,i.kt)("p",null,"If your application does not have built-in PulseAudio support, you can create a bridge to it by using ALSA. This can't be added in easily, so we wrote a little script that will do the work for you:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"ENV PULSE_SERVER=tcp:localhost:4317\nRUN curl -skL https://raw.githubusercontent.com/balenablocks/audio/master/scripts/alsa-bridge/debian-setup.sh | sh\n")),(0,i.kt)("p",null,"Check the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/balenablocks/audio/tree/master/scripts/alsa-bridge"},"audio block")," repository for alternative scripts if you are not running a debian based container.\nNote that you still need to set the ",(0,i.kt)("inlineCode",{parentName:"p"},"PULSE_SERVER")," variable."))}p.isMDXComponent=!0}}]);